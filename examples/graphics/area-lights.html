<!DOCTYPE html>
<html>
<head>
    <title>PlayCanvas Area lights</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/png" href="../playcanvas-favicon.png" />
    <script src="../../build/playcanvas.js"></script>
    <script src="../../build/playcanvas-extras.js"></script>
    <style>
        body { 
            margin: 0;
            overflow-y: hidden;
        }
    </style>
</head>

<body>
    <!-- The canvas element -->
    <canvas id="application-canvas"></canvas>

    <!-- The script -->
    <script>
        var canvas = document.getElementById("application-canvas");

        // Create the app and start the update loop
        var app = new pc.Application(canvas);

    </script>

    <!-- LUT table for area lights, included after the app has been created -->
    <script src="../assets/scripts/lights/area-light-lut.js"></script>

    <script>

        // helper function to create a primitive with shape type, position, scale, color
        function createPrimitive(primitiveType, position, scale, color, assetManifest) {

            // create material of specified color
            var material = new pc.StandardMaterial();
            material.diffuse = color;
            material.shininess = 80;
            material.useMetalness = true;

            if (assetManifest) {
                material.diffuseMap = assetManifest[0].asset.resource;
                material.normalMap = assetManifest[1].asset.resource;
                material.glossMap = assetManifest[2].asset.resource;
                material.metalness = 0.7;
            }

            material.update();

            // create primitive
            var primitive = new pc.Entity();
            primitive.addComponent('model', {
                type: primitiveType
            });
            primitive.model.material = material;

            // set position and scale and add it to scene
            primitive.setLocalPosition(position);
            primitive.setLocalScale(scale);
            app.root.addChild(primitive);

            return primitive;
        }

        // helper function to create area light including its visual representation in the world
        function createLight(position, scale, color, shape, shadows, range) {

            var light = new pc.Entity();
            light.addComponent("light", {
                type: "spot",
                shape: shape,
                color: color,
                intensity: 20,
                range: range,
                castShadows: shadows,
                innerConeAngle: 80,
                outerConeAngle: 85,
                shadowBias: 0.005,
                normalOffsetBias: 0.01,
                shadowResolution: 2048                
            });

            // front face quad
            var frontMaterial = new pc.StandardMaterial();
            frontMaterial.diffuse = new pc.Color(0, 0, 0);
            frontMaterial.useLighting = false;
            frontMaterial.update();

            // add plane that represents the area light
            light.addComponent("model", {
                type: (shape===pc.LIGHTSHAPE_DISK) ? "cone" : "plane",
                material: frontMaterial
            });

            light.setLocalScale(scale, (shape===pc.LIGHTSHAPE_DISK) ? 0.001 : scale, scale);
            light.translate(position);
            app.root.addChild(light);

            // black back face quad
            var backMaterial = new pc.StandardMaterial();
            backMaterial.emissive = color;
            backMaterial.useLighting = false;
            backMaterial.update();

            var backFace = new pc.Entity();
            backFace.addComponent("model", {
                type: (shape===pc.LIGHTSHAPE_DISK) ? "cone" : "plane",
                material: backMaterial
            });
            backFace.setLocalEulerAngles(-180, 0, 0);
            backFace.setLocalPosition(0, (shape===pc.LIGHTSHAPE_DISK) ? -10 : -0.001, 0);
            light.addChild(backFace);

            return light;
        }

        // A list of assets that need to be loaded
        var assetManifest = [
            {
                type: "texture",
                url: "../assets/textures/seaside-rocks01-color.jpg"
            },
            {
                type: "texture",
                url: "../assets/textures/seaside-rocks01-normal.jpg"
            },
            {
                type: "texture",
                url: "../assets/textures/seaside-rocks01-gloss.jpg"
            },
            {
                type: "container",
                url: "../assets/models/statue.glb"
            },
        ];

        // Load all assets and then run the example
        var assetsToLoad = assetManifest.length;
        assetManifest.forEach(function (entry) {
            app.assets.loadFromUrl(entry.url, entry.type, function (err, asset) {
                if (!err && asset) {
                    assetsToLoad--;
                    entry.asset = asset;
                    if (assetsToLoad === 0) {
                        run();
                    }
                }
            });
        });

        var light1, light2;
        function run() {

            app.start();

            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size
            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
            app.setCanvasResolution(pc.RESOLUTION_AUTO);

            window.addEventListener("resize", function () {
                app.resizeCanvas(canvas.width, canvas.height);
            });

            var miniStats = new pcx.MiniStats(app);

            // set up some general scene rendering properties
            app.scene.gammaCorrection = pc.GAMMA_SRGB;
            app.scene.toneMapping = pc.TONEMAP_ACES;

            // setup skydome
            app.scene.skyboxMip = 1;            // use top mipmap level of cubemap (full resolution)
            app.scene.skyboxIntensity = 0.4;    // make it darker

            // Load a cubemap asset. This DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.
            var cubemapAsset = new pc.Asset('helipad.dds', 'cubemap', {
                url: "../assets/cubemaps/helipad.dds"
            }, {
                type: pc.TEXTURETYPE_RGBM
            });
            app.assets.add(cubemapAsset);
            app.assets.load(cubemapAsset);
            cubemapAsset.ready(function () {
                app.scene.setSkybox(cubemapAsset.resources);
            });


            // create ground plane
            createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.3, 0.3), assetManifest);

             // Create a model entity and assign the statue model
             var statue = new pc.Entity();
             statue.addComponent("model", {
                type: "asset",
                asset: assetManifest[3].asset.resource.model
            });
            statue.setLocalScale(0.4, 0.4, 0.4);
            app.root.addChild(statue);


            // Create the camera, which renders entities 
            var camera = new pc.Entity();
            camera.addComponent("camera", {
                clearColor: new pc.Color(0.2, 0.2, 0.2),
                fov: 60
            });
            app.root.addChild(camera);
            camera.setLocalPosition(0, 6, 12);
            camera.lookAt(pc.Vec3.ZERO);

            // Create rectangle shape lights 
            light1 = createLight(new pc.Vec3(-5, 2, 2), 2, new pc.Color(1, 1, 1), pc.LIGHTSHAPE_RECT, true, 20);
            light2 = createLight(new pc.Vec3(5, 4, -2), 5, new pc.Color(1, 1, 0), pc.LIGHTSHAPE_DISK, true, 20);
        }

        // update things each frame
        var time = 0;
        var switchTime = 0;
        app.on("update", function (dt) {
            time += dt;

            if (light1) {
                var factor1 = (Math.sin(time) + 1) * 0.5;
                light1.setLocalEulerAngles(pc.math.lerp(-90, 110, factor1), 0, 90);
            }

            if (light2) {
                var factor2 = (Math.sin(time * 0.6) + 1) * 0.5;
                light2.setLocalEulerAngles(pc.math.lerp(50, 250, factor2), 0, 90);
            }

        });
    </script>
</body>
</html>
