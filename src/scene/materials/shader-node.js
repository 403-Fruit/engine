var id = 0;

/**
 * @param {string} f_or_t - function string or type string
 * @param {string} n - optional name string
 * @param {object} v - optional value
 * @class
 * @name ShaderGraphNode
 * @classdesc WIP ShaderGraphNode base class
 * @description WIP Create a new ShaderGraphNode instance.
 */
var ShaderGraphNode = function ShaderGraphNode(f_or_t, d_or_n, v) {
    this.name = (!v) ? "func_node" : "param_" + d_or_n + "_node";
    this.id = id++;

    // these are set by the node type/command
    this.inputName = [];
    this.inputType = [];
    this.outputName = [];
    this.outputType = [];

    // these are values set by user via graph or script
    this.inputNode = [];
    this.inputOutputIndex = [];

    // these are generated by graph traversal
    this.outputTempVarIndex = []; // initialized to -1

    if (f_or_t != undefined && d_or_n != undefined  && v != undefined) {
        this.setParam(f_or_t, d_or_n, v);
    } else if (f_or_t && v == undefined) {
        this.setFunctionString(f_or_t, d_or_n);

        this.name = "func_" + this.funcName + "_node";
    }
};

ShaderGraphNode.prototype._cloneInternal = function (clone) {
    clone.name = this.name;

    clone.inputNode = this.inputNode;
    clone.inputOutputIndex = this.inputOutputIndex;
    clone.inputName = this.inputName;
    clone.inputType = this.inputType;

    // clone.declarationString = this.declarationString;
    // clone.outputString = this.outputString;

    clone.outputName = this.outputName;
    clone.outputType = this.outputType;
};

ShaderGraphNode.prototype.clone = function () {
    var clone = new ShaderGraphNode();
    this._cloneInternal(clone);
    return clone;
};

ShaderGraphNode.prototype.defineOuputGetter = function (name, index) {
    // this.__defineGetter__(name, function() { return this.getOutput(this.outputName[index]); });
    Object.defineProperty(this, name, {
        get: function () {
            return this.getOutput(this.outputName[index]);
        }
    });
};

ShaderGraphNode.prototype.defineInputSetter = function (name, index) {
    // this.__defineSetter__(name, function(value) { this.setInput(this.inputName[index],value); });
    Object.defineProperty(this, name, {
        set: function (value) {
            this.setInput(this.inputName[index], value);
        },
        get: function () {
            var node = this.inputNode[index];
            if (node) {
                var outIndex = this.inputOutputIndex[index];
                if (outIndex > 0) {
                    var name = node.outputName[outIndex];
                    return { node: node, name: name };
                }
            }
            return node;
        }
    });
};

ShaderGraphNode.prototype.setParam = function (inType, inName, inValue) {
    this.param = { type: inType, name: inName, value: inValue };

    this.outputName.push(inName);
    this.outputType.push(inType);
    this.outputTempVarIndex.push(-1);

    this.defineOuputGetter(this.outputName[0], 0);
};

ShaderGraphNode.prototype.setFunctionString = function (f, d) {
    this.functionString = f.trim();

    var head = this.functionString.split(")")[0];
    var rettype_funcname = head.split("(")[0];
    var rettype = rettype_funcname.split(" ")[0];
    var params = head.split("(")[1].split(",");

    this.funcName = rettype_funcname.split(" ")[1];
    // TODO check for function name clashes - maybe replace func name in function string with hash key?

    if (d) //is there anything to declare (internal sub functions that this node is dependent on) 
    {
        this.functionString = d+'\n'+this.functionString;
    }

    if (rettype != "void") {
        this.outputName.push('ret');
        this.outputType.push(rettype);
        this.outputTempVarIndex.push(-1);
        this.ret = (this.outputName.length - 1);

        this.defineOuputGetter(this.outputName[0], 0);
    }

    for (var p = 0; p < params.length; p++) {
        var io_type_name = params[p].split(" ");

        if (io_type_name[0] === "") io_type_name.shift();

        if (io_type_name[0] === "out") {
            this.outputName.push(io_type_name[2]);
            this.outputType.push(io_type_name[1]);
            this.outputTempVarIndex.push(-1);

            this.defineOuputGetter(this.outputName[this.outputName.length - 1], this.outputName.length - 1);
        }
        if (io_type_name[0] === "in") {
            this.inputName.push(io_type_name[2]);
            this.inputType.push(io_type_name[1]);

            this.defineInputSetter(this.inputName[this.inputName.length - 1], this.inputName.length - 1);
        } else {
            // unsupported parameter !!! TODO add support for more parameter types?
        }
    }
};

ShaderGraphNode.prototype.setInput = function (tName, tOutput_or_node) {
    var inIndex = this.inputName.indexOf(tName);

    var outIndex = -1;

    var tOutput;
    if (tOutput_or_node) {
        if (tOutput_or_node instanceof ShaderGraphNode) {
            tOutput = { node: tOutput_or_node };
        } else {
            tOutput = tOutput_or_node;
        }

        if (tOutput.node) {
            outIndex = (tOutput.name) ? tOutput.node.outputName.indexOf(tOutput.name) : 0;
        }
    }

    // check transput valid and types match
    if (inIndex >= 0 && outIndex >= 0 && this.inputType[inIndex] === tOutput.node.outputType[outIndex]) {
        this.inputNode[inIndex] = tOutput.node;
        this.inputOutputIndex[inIndex] = outIndex;
    } else {
        // failed connection - mis-matching types !!! TODO: make user aware of this?
    }
};

ShaderGraphNode.prototype.getOutput = function (tName) {
    return { node: this, name: tName };
};

ShaderGraphNode.prototype.generateShaderGraph = function (graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList) {
    var isRoot = false;
    var i;

    if (!graphParamList && !graphFuncList && !graphTmpVarList && !graphNodeStringList) {
        isRoot = true;
        graphParamList = [];
        graphFuncList = [];
        graphTmpVarList = [];
        graphNodeStringList = [];
    }

    if (this.param) {
        graphParamList.push(this.param);

        var nodeParamString = '';
        // if already set, skip
        if (this.outputTempVarIndex[0] == -1) {
            this.outputTempVarIndex[0] = graphTmpVarList.length;
            graphTmpVarList.push([this.outputType[0], this.outputName[0]]);

            // nodeParamString += this.outputType[0]+' '+this.outputName[0]+'_'+this.outputTempVarIndex[0]+' = '+this.outputName[0]+';\n';
            nodeParamString += '#define ' + this.outputName[0] + '_' + this.outputTempVarIndex[0] + ' ' + this.outputName[0] + '\n';
        }

        graphNodeStringList.push(nodeParamString);
    }

    if (this.functionString) {
        var funcString = '';

        if ( (this.funcName[this.funcName.length - 2] === 'P') && (this.funcName[this.funcName.length - 1] === 'S') ) {
            funcString += '#ifdef SG_PS\n';
        } else if ( (this.funcName[this.funcName.length - 2] === 'V') && (this.funcName[this.funcName.length - 1] === 'S') ) {
            funcString += '#ifdef SG_VS\n';
        }

        funcString += this.functionString + '\n';

        if ( (this.funcName[this.funcName.length - 2] === 'P') && (this.funcName[this.funcName.length - 1] === 'S') ) {
            funcString += '#endif //SG_PS\n';
        } else if ( (this.funcName[this.funcName.length - 2] === 'V') && (this.funcName[this.funcName.length - 1] === 'S') ) {
            funcString += '#endif //SG_VS\n';
        }

        graphFuncList.push(funcString); // TODO (probably before it can compile) remove duplicates

        // get the graphs index for all inputs
        var inputTempVarIndex = [];
        for (i = 0; i < this.inputNode.length; i++) {
            if (this.inputNode[i]) {
                if (this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]] == -1) {
                    this.inputNode[i].generateShaderGraph(graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList);
                }
                inputTempVarIndex[i] = this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]];
            }
        }
        var nodeString = '';
        // construct the func call string
        if (isRoot) {
            var skip_colalpha = false;
            for (i = 0; i < this.inputNode.length; i++) {
                if (this.inputNode[i]) {
                    switch (this.inputName[i]) {
                        case 'rgba':
                            nodeString += '#ifdef SG_PS\n';
                            nodeString += '    gl_FragColor = ' + graphTmpVarList[inputTempVarIndex[i]][1] + '_' + inputTempVarIndex[i] + ';\n';
                            nodeString += '#endif //SG_PS\n';
                            skip_colalpha = true;
                            break;
                        case 'color':
                            if (skip_colalpha === false) {
                                nodeString += '#ifdef SG_PS\n';
                                nodeString += '    gl_FragColor.rgb = ' + graphTmpVarList[inputTempVarIndex[i]][1] + '_' + inputTempVarIndex[i] + ';\n';
                                nodeString += '#endif //SG_PS\n';
                            }
                            break;
                        case 'alpha':
                            if (skip_colalpha === false) {
                                nodeString += '#ifdef SG_PS\n';
                                nodeString += '    gl_FragColor.a = ' + graphTmpVarList[inputTempVarIndex[i]][1] + '_' + inputTempVarIndex[i] + ';\n';
                                nodeString += '#endif //SG_PS\n';
                            }
                            break;
                        case 'vertexOffset':
                            nodeString += '#ifdef SG_VS\n';
                            nodeString += '    vec3 shaderGraphVertexOffset = ' + graphTmpVarList[inputTempVarIndex[i]][1] + '_' + inputTempVarIndex[i] + ';\n';
                            nodeString += '#endif //SG_VS\n';
                            break;
                    }
                }
            }
        } else {
            if ( (this.funcName[this.funcName.length - 2] === 'P') && (this.funcName[this.funcName.length - 1] === 'S') ) {
                nodeString += '#ifdef SG_PS\n';
            } else if ( (this.funcName[this.funcName.length - 2] === 'V') && (this.funcName[this.funcName.length - 1] === 'S') ) {
                nodeString += '#ifdef SG_VS\n';
            }

            // assign graph index value to each output (if not already assigned)
            for (i = 0; i < this.outputTempVarIndex.length; i++) {
                // if already set, skip
                if (this.outputTempVarIndex[i] == -1) {
                    this.outputTempVarIndex[i] = graphTmpVarList.length;
                    graphTmpVarList.push([this.outputType[i], this.outputName[i]]);

                    nodeString += this.outputType[i] + ' ' + this.outputName[i] + '_' + this.outputTempVarIndex[i] + ';\n';
                }
            }

            var skipRet = false;
            // TODO ensure there isn't a name clash!!!
            if (this.outputName[0] === 'ret') {
                nodeString += graphTmpVarList[this.outputTempVarIndex[0]][1] + '_' + this.outputTempVarIndex[0] + ' = ';
                skipRet = true;
            }

            nodeString += this.funcName + '(';
            for (i = 0; i < this.inputNode.length; i++) {
                nodeString += graphTmpVarList[inputTempVarIndex[i]][1] + '_' + inputTempVarIndex[i];
                if (this.outputTempVarIndex.length > ((skipRet) ? 1 : 0) || i < (this.inputNode.length - 1)) nodeString += ', ';
            }
            for (i = ((skipRet) ? 1 : 0); i < this.outputTempVarIndex.length; i++) {
                nodeString += graphTmpVarList[this.outputTempVarIndex[i]][1] + '_' + this.outputTempVarIndex[i];
                if (i < (this.outputTempVarIndex.length - 1)) nodeString += ', ';
            }
            nodeString += ');\n';

            if ( (this.funcName[this.funcName.length - 2] === 'P') && (this.funcName[this.funcName.length - 1] === 'S') ) {
                nodeString += '#endif //SG_PS\n';
            } else if ( (this.funcName[this.funcName.length - 2] === 'V') && (this.funcName[this.funcName.length - 1] === 'S') ) {
                nodeString += '#endif //SG_VS\n';
            }
        }
        graphNodeStringList.push(nodeString);
    }

    if (isRoot) {
        this.shaderGraphFuncString = '';

        for (i = 0; i < graphFuncList.length; i++) {
            this.shaderGraphFuncString += graphFuncList[i] + '\n';
        }

        this.shaderGraphNodeString = '';
        for (i = 0; i < graphNodeStringList.length; i++) {
            this.shaderGraphNodeString += graphNodeStringList[i] + '\n';
        }

        this.params = graphParamList;
    }
};

var shadergraph = {};

shadergraph.textureSample2D = function (texture, uv) {
    var texSampleNode = new ShaderGraphNode('void texSample(in sampler2D tex, in vec2 uv, out vec4 rgba, out vec3 color, out float alpha) {\n vec4 samp=texture2D(tex, uv);\n rgba=samp;\n color=samp.rgb;\n alpha=samp.a;\n}');
    texSampleNode.tex = new ShaderGraphNode('sampler2D', 'tex', texture);
    texSampleNode.uv = uv;
    return texSampleNode;
};

Object.defineProperty(shadergraph, 'uv0', {
    get: function () {
        return new ShaderGraphNode('vec2 uv0() { return vUv0; }');
    }
});

shadergraph.customNode = function (f,d) {
    var customNode = new ShaderGraphNode(f,d);
    return customNode;
};

Object.defineProperty(shadergraph, 'worldPosPS', {
    get: function () {
        return new ShaderGraphNode('vec3 wpPS() { return vPosition; }');
    }
});

Object.defineProperty(shadergraph, 'worldNormPS', {
    get: function () {
        return new ShaderGraphNode('vec3 wnPS() { return vNormal; }');
    }
});

Object.defineProperty(shadergraph, 'worldPosVS', {
    get: function () {
        return new ShaderGraphNode('vec3 wpVS() { return getWorldPositionNM(); }');
    }
});

Object.defineProperty(shadergraph, 'worldNormVS', {
    get: function () {
        return new ShaderGraphNode('vec3 wnVS() { return getWorldNormalNM(); }');
    }
});

shadergraph.param = function (type, name, value) {
    var paramNode = new ShaderGraphNode(type, name, value);
    return paramNode;
};

shadergraph.root = function (color, alpha, vertOff) {
    var rootNode = new ShaderGraphNode('void root(in vec4 rgba, in vec3 color, in float alpha, in vec3 vertexOffset){}');
    rootNode.color = color;
    rootNode.alpha = alpha;
    rootNode.vertexOffset = vertOff;
    return rootNode;
};

export { ShaderGraphNode, shadergraph };
