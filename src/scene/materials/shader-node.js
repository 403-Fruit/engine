Object.assign(pc, function () {
    var id = 0;

    /**
     * @class
     * @name pc.ShaderGraphNode
     * @classdesc ShaderGraphNode base class
     * @description Create a new ShaderGraphNode instance.
     */
    var ShaderGraphNode = function ShaderGraphNode() {
        this.name = "Untitled";
        this.id = id++;

        //these are set by the node type/command
        this.inputName = [];
        this.inputType = [];
        this.outputName = [];
        this.outputType = [];    
        

        //these are values set by user via graph or script
        this.inputNode = [];
        this.inputOutputIndex = [];

        //these are generated by graph traversal
        this.outputTempVarIndex = []; //initialized to -1

//        this.functionList = [];
//        this.paramList = [];
//        this.outputList = [];
    };

    ShaderGraphNode.prototype._cloneInternal = function (clone) {
        clone.name = this.name;

        clone.inputNode = this.inputNode ;
        clone.inputOutputIndex = this.inputOutputIndex;
        clone.inputName = this.inputName;
        clone.inputType = this.inputType;

        //clone.declarationString = this.declarationString;
        //clone.outputString = this.outputString;

        clone.outputName = this.outputName;
        clone.outputType = this.outputType;      
    };

    ShaderGraphNode.prototype.clone = function () {
        var clone = new pc.Material();
        this._cloneInternal(clone);
        return clone;
    };

    ShaderGraphNode.prototype.setParam = function (inType, inName, inValue) {
        this.param={type: inType, name: inName, value: inValue};

        this.outputName.push(inName);
        this.outputType.push(inType); 
        this.outputTempVarIndex.push(-1); 
    };

    ShaderGraphNode.prototype.setFunctionString = function (f) {
        this.functionString=f;

        var head = f.split(")")[0];
        var rettype_funcname = head.split("(")[0];
        var rettype = rettype_funcname.split(" ")[0];
        var params = head.split("(")[1].split(",");

        this.funcName = rettype_funcname.split(" ")[1]; 
        //TODO check for function name clashes - maybe replace func name in function string with hash key?

        if (rettype!="void")
        {
            this.outputName.push('ret');
            this.outputType.push(rettype); 
            this.outputTempVarIndex.push(-1); 
        }

        for (var p=0;p<params.length;p++)
        {
            var io_type_name=params[p].split(" ");

            if (io_type_name[0]==="") io_type_name.shift();

            if (io_type_name[0]==="out")
            {
                this.outputName.push(io_type_name[2]);
                this.outputType.push(io_type_name[1]);
                this.outputTempVarIndex.push(-1); 
            }
            if (io_type_name[0]==="in")
            {
                this.inputName.push(io_type_name[2]);
                this.inputType.push(io_type_name[1]); 
            }
            else 
            {
                //unsupported parameter !!! TODO add support for more parameter types?
            }
        }
    };

    ShaderGraphNode.prototype.setInput = function (inName, inNode, outName) {
        
        var inIndex = this.inputName.indexOf(inName);
        var outIndex = (outName) ? inNode.outputName.indexOf(outName) : 0;
        
        //check transput valid and types match
        if (inIndex>=0 && outIndex>=0 && this.inputType[inIndex]===inNode.outputType[outIndex])
        {
            this.inputNode[inIndex]=inNode;
            this.inputOutputIndex[inIndex]=outIndex;
        }
        else
        {
            //failed connection - mis-matching types !!! TODO: make user aware of this?
        }
    }

    ShaderGraphNode.prototype.genOutputs = function (graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList) {
        var isRoot=false;

        if (!graphParamList && !graphFuncList && !graphTmpVarList && !graphNodeStringList)
        {
            isRoot=true;
            graphParamList = [];
            graphFuncList = [];
            graphTmpVarList = [];
            graphNodeStringList = [];
        }

        if (this.param)
        {
            graphParamList.push(this.param);

            var nodeString='';
            if (this.outputTempVarIndex[0]==-1) //if already set, skip
            {
                this.outputTempVarIndex[0]=graphTmpVarList.length;
                graphTmpVarList.push([this.outputType[0], this.outputName[0]]);

                //nodeString += this.outputType[0]+' '+this.outputName[0]+'_'+this.outputTempVarIndex[0]+' = '+this.outputName[0]+';\n';
                nodeString += '#define '+this.outputName[0]+'_'+this.outputTempVarIndex[0]+' '+this.outputName[0]+'\n';
            }       

            graphNodeStringList.push(nodeString);     
        }

        if (this.functionString)
        {
            graphFuncList.push(this.functionString); //TODO (probably before it can compile) remove duplicates

            //get the graphs index for all inputs
            var inputTempVarIndex=[];
            for (var i=0;i<this.inputNode.length;i++)
            {
                if (this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]]==-1)
                {
                    this.inputNode[i].genOutputs(graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList);
                }
                inputTempVarIndex[i]=this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]];
            }

            var nodeString='';
            //assign graph index value to each output (if not already assigned)
            for (var i=0;i<this.outputTempVarIndex.length;i++)
            {
                if (this.outputTempVarIndex[i]==-1) //if already set, skip
                {
                    this.outputTempVarIndex[i]=graphTmpVarList.length;
                    graphTmpVarList.push([this.outputType[i], this.outputName[i]]);

                    nodeString += this.outputType[i]+' '+this.outputName[i]+'_'+this.outputTempVarIndex[i]+';\n';
                }
            }
            //construct the func call string
            var skipRet=false;
            if (this.outputName[0]==='ret') //TODO ensure there isn't a name clash!!!
            {
                if (isRoot)
                {
                    nodeString+='gl_FragColor = ';
                }
                else
                {
                    nodeString+=graphTmpVarList[this.outputTempVarIndex[0]][1]+'_'+this.outputTempVarIndex[0]+' = ';
                }
                skipRet=true;
            }

            nodeString+= this.funcName+'(';
            for (var i=0;i<this.inputNode.length;i++)
            {
                nodeString+=graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i];
                if (this.outputTempVarIndex.length>((skipRet)?1:0) || i<(this.inputNode.length-1)) nodeString+=', ';
            }
            for (var i=((skipRet)?1:0);i<this.outputTempVarIndex.length;i++)
            {
                nodeString+=graphTmpVarList[this.outputTempVarIndex[i]][1]+'_'+this.outputTempVarIndex[i];
                if (i<(this.outputTempVarIndex.length-1)) nodeString+=', ';
            }        
            nodeString+=');\n';

            graphNodeStringList.push(nodeString);
        }

        if (isRoot)
        {
            this.shaderGraphFuncString=''; //TODO: shader precision stuff? extension stuff?

 /*           for (var i=0;i<graphParamList.length;i++)
            {
                this.shaderGraphString+=graphParamList[i].type+' '+graphParamList[i].name+';\n';
            }
            this.shaderGraphString+='\n';*/

            for (var i=0;i<graphFuncList.length;i++)
            {
                this.shaderGraphFuncString+=graphFuncList[i]+'\n\n';
            }
            
            this.shaderGraphNodeString='';
            for (var i=0;i<graphNodeStringList.length;i++)
            {
                this.shaderGraphNodeString+=graphNodeStringList[i]+'\n';
            }
            //this.shaderGraphString+='\n';

            this.params=graphParamList;
        }
    };

    return {
        ShaderGraphNode: ShaderGraphNode
    };
}());
