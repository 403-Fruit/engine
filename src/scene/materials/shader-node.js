Object.assign(pc, function () {
    var id = 0;

    /**
     * @class
     * @name pc.ShaderGraphNode
     * @classdesc WIP ShaderGraphNode base class
     * @description WIP Create a new ShaderGraphNode instance.
     */
    var ShaderGraphNode = function ShaderGraphNode(f_or_t, n, v) {
        this.name = (!n)?"func_node" : "param_"+n+"_node";
        this.id = id++;

        //these are set by the node type/command
        this.inputName = [];
        this.inputType = [];
        this.outputName = [];
        this.outputType = [];    
        
        //these are values set by user via graph or script
        this.inputNode = [];
        this.inputOutputIndex = [];

        //these are generated by graph traversal
        this.outputTempVarIndex = []; //initialized to -1

        if (f_or_t!=undefined && n!=undefined  && v!=undefined)
        {
            this.setParam(f_or_t, n, v);
        }
        else if (f_or_t && n==undefined && v==undefined)
        {
            this.setFunctionString(f_or_t);

            this.name = "func_"+this.funcName+"_node";
        }
    };

    ShaderGraphNode.prototype._cloneInternal = function (clone) {
        clone.name = this.name;

        clone.inputNode = this.inputNode;
        clone.inputOutputIndex = this.inputOutputIndex;
        clone.inputName = this.inputName;
        clone.inputType = this.inputType;

        //clone.declarationString = this.declarationString;
        //clone.outputString = this.outputString;

        clone.outputName = this.outputName;
        clone.outputType = this.outputType;      
    };

    ShaderGraphNode.prototype.clone = function () {
        var clone = new pc.Material();
        this._cloneInternal(clone);
        return clone;
    };

    ShaderGraphNode.prototype.defineOuputGetter = function (name, index) {
        //this.__defineGetter__(name, function() { return this.getOutput(this.outputName[index]); });
        Object.defineProperty(this, name, {
            get: function() {
                return this.getOutput(this.outputName[index]);
            }
          });

    };

    ShaderGraphNode.prototype.defineInputSetter = function (name, index) {
        //this.__defineSetter__(name, function(value) { this.setInput(this.inputName[index],value); });
        Object.defineProperty(this, name, {
            set: function(value) {
                this.setInput(this.inputName[index],value); 
            }
          });
    };

    ShaderGraphNode.prototype.setParam = function (inType, inName, inValue) {
        this.param={type: inType, name: inName, value: inValue};

        this.outputName.push(inName);
        this.outputType.push(inType); 
        this.outputTempVarIndex.push(-1); 
        
        this.defineOuputGetter(this.outputName[0], 0);  
    };

    ShaderGraphNode.prototype.setFunctionString = function (f) {
        this.functionString=f;

        var head = f.split(")")[0];
        var rettype_funcname = head.split("(")[0];
        var rettype = rettype_funcname.split(" ")[0];
        var params = head.split("(")[1].split(",");

        this.funcName = rettype_funcname.split(" ")[1]; 
        //TODO check for function name clashes - maybe replace func name in function string with hash key?

        if (rettype!="void")
        {
            this.outputName.push('ret');
            this.outputType.push(rettype); 
            this.outputTempVarIndex.push(-1); 
            this['ret'] = (this.outputName.length-1);

            this.defineOuputGetter(this.outputName[0], 0);   
        }

        for (var p=0;p<params.length;p++)
        {
            var io_type_name=params[p].split(" ");

            if (io_type_name[0]==="") io_type_name.shift();

            if (io_type_name[0]==="out")
            {
                this.outputName.push(io_type_name[2]);
                this.outputType.push(io_type_name[1]);
                this.outputTempVarIndex.push(-1); 

                this.defineOuputGetter(this.outputName[this.outputName.length-1], this.outputName.length-1);  
            }
            if (io_type_name[0]==="in")
            {
                this.inputName.push(io_type_name[2]);
                this.inputType.push(io_type_name[1]); 

                this.defineInputSetter(this.inputName[this.inputName.length-1], this.inputName.length-1);         
            }
            else 
            {
                //unsupported parameter !!! TODO add support for more parameter types?
            }
        }
    };

    ShaderGraphNode.prototype.setInput = function (tName, tOutput_or_node) 
    {    
        var inIndex = this.inputName.indexOf(tName);

        var outIndex = -1;

        var tOutput;
        if (tOutput_or_node) 
        {
            if (tOutput_or_node instanceof ShaderGraphNode)
            {
                tOutput = {node: tOutput_or_node};
            }
            else
            {
                tOutput = tOutput_or_node;
            }

            if (tOutput.node)
            {
                outIndex = (tOutput.name) ? tOutput.node.outputName.indexOf(tOutput.name) : 0;
            }
        }

        //check transput valid and types match
        if (inIndex>=0 && outIndex>=0 && this.inputType[inIndex]===tOutput.node.outputType[outIndex])
        {
            this.inputNode[inIndex]=tOutput.node;
            this.inputOutputIndex[inIndex]=outIndex;
        }
        else
        {
            //failed connection - mis-matching types !!! TODO: make user aware of this?
        }
    }

    ShaderGraphNode.prototype.getOutput = function (tName) {
        return {node: this, name: tName};
    }

    ShaderGraphNode.prototype.generateShaderGraph = function (graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList) {
        var isRoot=false;

        if (!graphParamList && !graphFuncList && !graphTmpVarList && !graphNodeStringList)
        {
            isRoot=true;
            graphParamList = [];
            graphFuncList = [];
            graphTmpVarList = [];
            graphNodeStringList = [];
        }

        if (this.param)
        {
            graphParamList.push(this.param);

            var nodeString='';
            if (this.outputTempVarIndex[0]==-1) //if already set, skip
            {
                this.outputTempVarIndex[0]=graphTmpVarList.length;
                graphTmpVarList.push([this.outputType[0], this.outputName[0]]);

                //nodeString += this.outputType[0]+' '+this.outputName[0]+'_'+this.outputTempVarIndex[0]+' = '+this.outputName[0]+';\n';
                nodeString += '#define '+this.outputName[0]+'_'+this.outputTempVarIndex[0]+' '+this.outputName[0]+'\n';
            }       

            graphNodeStringList.push(nodeString);     
        }

        if (this.functionString)
        {
            var funcString='';

            if ( (this.funcName[this.funcName.length-2]==='P') && (this.funcName[this.funcName.length-1]==='S') )
            {
                funcString+='#ifdef SG_PS\n';
            }
            else if ( (this.funcName[this.funcName.length-2]==='V') && (this.funcName[this.funcName.length-1]==='S') )
            {
                funcString+='#ifdef SG_VS\n';
            }

            funcString+=this.functionString+'\n';

            if ( (this.funcName[this.funcName.length-2]==='P') && (this.funcName[this.funcName.length-1]==='S') )
            {
                funcString+='#endif //SG_PS\n';
            }
            else if ( (this.funcName[this.funcName.length-2]==='V') && (this.funcName[this.funcName.length-1]==='S') )
            {
                funcString+='#endif //SG_VS\n';
            }    

            graphFuncList.push(funcString); //TODO (probably before it can compile) remove duplicates

            //get the graphs index for all inputs
            var inputTempVarIndex=[];
            for (var i=0;i<this.inputNode.length;i++)
            {
                if (this.inputNode[i])
                {
                    if (this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]]==-1)
                    {
                        this.inputNode[i].generateShaderGraph(graphParamList, graphFuncList, graphTmpVarList, graphNodeStringList);
                    }
                    inputTempVarIndex[i]=this.inputNode[i].outputTempVarIndex[this.inputOutputIndex[i]];
                }
            }

            var nodeString='';
            //construct the func call string
            if (isRoot)
            {
                var skip_colalpha=false;
                for (var i=0;i<this.inputNode.length;i++)
                {
                    if (this.inputNode[i])
                    {                    
                        switch (this.inputName[i])
                        {
                            case 'rgba':
                                nodeString+='#ifdef SG_PS\n';
                                nodeString+='    gl_FragColor = '+graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i]+';\n';
                                nodeString+='#endif //SG_PS\n';
                                skip_colalpha=true;
                                break;                            
                            case 'color':
                                if (skip_colalpha===false)
                                {
                                    nodeString+='#ifdef SG_PS\n';
                                    nodeString+='    gl_FragColor.rgb = '+graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i]+';\n';
                                    nodeString+='#endif //SG_PS\n';
                                }
                                break;
                            case 'alpha':
                                if (skip_colalpha===false)
                                {
                                    nodeString+='#ifdef SG_PS\n';
                                    nodeString+='    gl_FragColor.a = '+graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i]+';\n';
                                    nodeString+='#endif //SG_PS\n';
                                }
                                break;       
                            case 'vertexOffset':
                                nodeString+='#ifdef SG_VS\n';
                                nodeString+='    vec3 shaderGraphVertexOffset = '+graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i]+';\n';
                                nodeString+='#endif //SG_VS\n';
                            break;                                              
                        }
                    }
                }
            }
            else
            {
                if ( (this.funcName[this.funcName.length-2]==='P') && (this.funcName[this.funcName.length-1]==='S') )
                {
                    nodeString+='#ifdef SG_PS\n';
                }
                else if ( (this.funcName[this.funcName.length-2]==='V') && (this.funcName[this.funcName.length-1]==='S') )
                {
                    nodeString+='#ifdef SG_VS\n';
                }

                //assign graph index value to each output (if not already assigned)
                for (var i=0;i<this.outputTempVarIndex.length;i++)
                {
                    if (this.outputTempVarIndex[i]==-1) //if already set, skip
                    {
                        this.outputTempVarIndex[i]=graphTmpVarList.length;
                        graphTmpVarList.push([this.outputType[i], this.outputName[i]]);

                        nodeString += this.outputType[i]+' '+this.outputName[i]+'_'+this.outputTempVarIndex[i]+';\n';
                    }
                }

                var skipRet=false;
                if (this.outputName[0]==='ret') //TODO ensure there isn't a name clash!!!
                {
                    nodeString+=graphTmpVarList[this.outputTempVarIndex[0]][1]+'_'+this.outputTempVarIndex[0]+' = ';
                    skipRet=true;
                }

                nodeString+= this.funcName+'(';
                for (var i=0;i<this.inputNode.length;i++)
                {
                    nodeString+=graphTmpVarList[inputTempVarIndex[i]][1]+'_'+inputTempVarIndex[i];
                    if (this.outputTempVarIndex.length>((skipRet)?1:0) || i<(this.inputNode.length-1)) nodeString+=', ';
                }
                for (var i=((skipRet)?1:0);i<this.outputTempVarIndex.length;i++)
                {
                    nodeString+=graphTmpVarList[this.outputTempVarIndex[i]][1]+'_'+this.outputTempVarIndex[i];
                    if (i<(this.outputTempVarIndex.length-1)) nodeString+=', ';
                }        
                nodeString+=');\n';

                if ( (this.funcName[this.funcName.length-2]==='P') && (this.funcName[this.funcName.length-1]==='S') )
                {
                    nodeString+='#endif //SG_PS\n';
                }
                else if ( (this.funcName[this.funcName.length-2]==='V') && (this.funcName[this.funcName.length-1]==='S') )
                {
                    nodeString+='#endif //SG_VS\n';
                }                
            }
            graphNodeStringList.push(nodeString);
        }

        if (isRoot)
        {
            this.shaderGraphFuncString='';

            for (var i=0;i<graphFuncList.length;i++)
            {
                this.shaderGraphFuncString+=graphFuncList[i]+'\n';
            }
            
            this.shaderGraphNodeString='';
            for (var i=0;i<graphNodeStringList.length;i++)
            {
                this.shaderGraphNodeString+=graphNodeStringList[i]+'\n';
            }

            this.params=graphParamList;
        }
    };

    return {
        ShaderGraphNode: ShaderGraphNode
    };
}());

Object.assign(pc, function () {
    var sgn={};

    sgn.textureSample2D = function(texture, uv) 
    {
        var texSampleNode = new pc.ShaderGraphNode('void texSample(in sampler2D texture, in vec2 uv, out vec4 rgba, out vec3 color, out float alpha) {\n vec4 sample=texture2D(texture, uv);\n rgba=sample;\n color=sample.rgb;\n alpha=sample.a;\n}');
        texSampleNode.texture = new pc.ShaderGraphNode('sampler2D', 'texture', texture);
        texSampleNode.uv = uv;
        return texSampleNode;
    }

    //sgn.__defineGetter__('uv0', function() { return new pc.ShaderGraphNode('vec2 uv0() { return vUv0; }'); });
    Object.defineProperty(sgn, 'uv0', {
        get: function() {
            return new pc.ShaderGraphNode('vec2 uv0() { return vUv0; }');
        }
      });

    sgn.customNode = function(f) 
    {
        var customNode = new pc.ShaderGraphNode(f);
        return customNode;
    }

    //sgn.__defineGetter__('worldPosVS', function() { return new pc.ShaderGraphNode('vec3 wpVS() { return getWorldPositionNM(); }'); });
    Object.defineProperty(sgn, 'worldPosVS', {
        get: function() {
            return new pc.ShaderGraphNode('vec3 wpVS() { return getWorldPositionNM(); }');
        }
      });
    
    //sgn.__defineGetter__('worldNormVS', function() { return new pc.ShaderGraphNode('vec3 wnVS() { return getWorldNormalNM(); }'); });
    Object.defineProperty(sgn, 'worldNormVS', {
        get: function() {
            return new pc.ShaderGraphNode('vec3 wnVS() { return getWorldNormalNM(); }');
        }
      });

    sgn.param = function(type, name, value) 
    {
        var paramNode = new pc.ShaderGraphNode(type, name, value);
        return paramNode;
    }

    sgn.root = function(color, alpha, vertOff) 
    {
        var rootNode = new pc.ShaderGraphNode('void root(in vec4 rgba, in vec3 color, in float alpha, in vec3 vertexOffset){}');
        rootNode.color = color;
        rootNode.alpha = alpha;
        rootNode.vertexOffset = vertOff;
        return rootNode;  
    }
    return {
        sgn: sgn
    };
}());